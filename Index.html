import React, { useEffect, useMemo, useRef, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Separator } from "@/components/ui/separator";
import { Checkbox } from "@/components/ui/checkbox";
import {
  ResponsiveContainer,
  ComposedChart,
  Bar,
  Line,
  XAxis,
  YAxis,
  Tooltip,
  CartesianGrid,
  BarChart,
  Legend,
} from "recharts";
import { AlertTriangle, FileUp, Filter, Sparkles, X } from "lucide-react";

/**
 * OEE Excel Paste Dashboard (client-only)
 *
 * Paste Excel-copied data (TSV) or upload a CSV.
 * Auto-detects common columns (Date, Shift, Line, Event, Duration minutes).
 * Builds a single-line dashboard with:
 * - Pareto chart (events by downtime)
 * - Top 10 / Top 5 events (click to drill-down)
 * - Cost impact using your line rates
 * - Event log table
 * - Filters: date range + shifts + search
 *
 * NOTE: This version shows 4 tabs ONLY (Line A, B, C, D). No multi-line combined view.
 */

// ---------- Config ----------

const LINE_TABS = ["Line A", "Line B", "Line C", "Line D"] as const;

type LineTab = (typeof LINE_TABS)[number];

const LINE_COLOR: Record<string, string> = {
  "LINE A": "#2563eb", // blue
  "LINE B": "#16a34a", // green
  "LINE C": "#f97316", // orange
  "LINE D": "#a855f7", // purple
  UNKNOWN: "#64748b", // slate
};

// Downtime cost per HOUR
const COST_PER_HOUR: Record<string, number> = {
  "LINE A": 1003.5,
  "LINE B": 1003.5,
  "LINE C": 1299.33,
  "LINE D": 1299.33,
};

const SHIFT_OPTIONS = ["A", "B", "C", "D"] as const;

type Shift = (typeof SHIFT_OPTIONS)[number];

type Row = {
  id: string;
  dt: Date | null;
  dateISO: string | null; // YYYY-MM-DD
  shift: Shift | null;
  line: string; // normalized "LINE X" or UNKNOWN
  event: string;
  downtimeMin: number;
  raw: Record<string, string>;
};

// ---------- Helpers ----------

function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

function round(n: number, dp = 2) {
  const p = Math.pow(10, dp);
  return Math.round(n * p) / p;
}

function fmtMoney(n: number) {
  if (!Number.isFinite(n)) return "$0";
  return n.toLocaleString(undefined, { style: "currency", currency: "USD" });
}

function fmtHoursFromMin(min: number) {
  const h = min / 60;
  return `${round(h, 2).toLocaleString()} h`;
}

function fmtMin(min: number) {
  return `${round(min, 0).toLocaleString()} min`;
}

function toISODate(d: Date) {
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${day}`;
}

function tryParseNumber(s: string): number | null {
  if (s == null) return null;
  const cleaned = String(s)
    .trim()
    .replace(/,/g, "")
    .replace(/^\+/, "");
  if (!cleaned) return null;
  const n = Number(cleaned);
  return Number.isFinite(n) ? n : null;
}

// Excel serial dates: days since 1899-12-30 (common behavior)
function excelSerialToDate(serial: number): Date {
  const base = new Date(Date.UTC(1899, 11, 30));
  const ms = serial * 86400 * 1000;
  return new Date(base.getTime() + ms);
}

function tryParseDate(value: string): Date | null {
  if (!value) return null;
  const v = String(value).trim();

  // Numeric? Could be Excel serial date
  const maybeNum = tryParseNumber(v);
  if (maybeNum != null && maybeNum > 20000 && maybeNum < 80000) {
    const d = excelSerialToDate(maybeNum);
    if (!Number.isNaN(d.getTime())) return d;
  }

  // ISO or locale parse
  const d1 = new Date(v);
  if (!Number.isNaN(d1.getTime())) return d1;

  // Try MM/DD/YYYY and variations
  const m = v.match(
    /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/
  );
  if (m) {
    const mm = clamp(parseInt(m[1], 10), 1, 12);
    const dd = clamp(parseInt(m[2], 10), 1, 31);
    let yy = parseInt(m[3], 10);
    if (yy < 100) yy += 2000;
    const hh = m[4] ? clamp(parseInt(m[4], 10), 0, 23) : 0;
    const mi = m[5] ? clamp(parseInt(m[5], 10), 0, 59) : 0;
    const ss = m[6] ? clamp(parseInt(m[6], 10), 0, 59) : 0;
    const d = new Date(yy, mm - 1, dd, hh, mi, ss);
    if (!Number.isNaN(d.getTime())) return d;
  }

  return null;
}

function normalizeHeader(h: string) {
  return String(h)
    .trim()
    .toLowerCase()
    .replace(/\s+/g, " ")
    .replace(/[^a-z0-9 ]/g, "");
}

function normalizeLine(v: string): string {
  const s = String(v || "").trim().toUpperCase();
  if (!s) return "UNKNOWN";

  if (s === "A" || s.includes("LINE A") || s === "LINEA") return "LINE A";
  if (s === "B" || s.includes("LINE B") || s === "LINEB") return "LINE B";
  if (s === "C" || s.includes("LINE C") || s === "LINEC") return "LINE C";
  if (s === "D" || s.includes("LINE D") || s === "LINED") return "LINE D";

  // Sometimes Excel has workcenter like "A - Processor"
  if (s.startsWith("A")) return "LINE A";
  if (s.startsWith("B")) return "LINE B";
  if (s.startsWith("C")) return "LINE C";
  if (s.startsWith("D")) return "LINE D";

  // Keep unknowns from polluting charts
  return s.startsWith("LINE ") ? s : "UNKNOWN";
}

function normalizeShift(v: string): Shift | null {
  const s = String(v || "").trim().toUpperCase();
  if (SHIFT_OPTIONS.includes(s as Shift)) return s as Shift;
  for (const sh of SHIFT_OPTIONS) {
    if (s.includes(`SHIFT ${sh}`)) return sh;
  }
  return null;
}

function safeEventName(v: string) {
  const s = String(v || "").trim();
  if (!s) return "(Unspecified event)";
  return s.length > 120 ? s.slice(0, 117) + "…" : s;
}

function getCostPerHour(line: string): number {
  return COST_PER_HOUR[line] ?? 0;
}

function computeRowCostUSD(r: Row): number {
  const cph = getCostPerHour(r.line);
  return (r.downtimeMin / 60) * cph;
}

function detectDelimiter(text: string) {
  return text.includes("\t") ? "\t" : ",";
}

function parseDelimited(text: string): { headers: string[]; rows: string[][] } {
  const normalized = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  const lines = normalized
    .split("\n")
    .map((l) => l.replace(/\u00a0/g, " "))
    .filter((l) => l.trim().length > 0);
  if (lines.length === 0) return { headers: [], rows: [] };

  const delim = detectDelimiter(text);

  const splitLine = (line: string) => {
    if (delim === "\t") return line.split("\t");

    // minimal CSV parser: handles quoted cells with commas
    const out: string[] = [];
    let cur = "";
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQuotes && line[i + 1] === '"') {
          cur += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (ch === "," && !inQuotes) {
        out.push(cur);
        cur = "";
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out;
  };

  const header = splitLine(lines[0]).map((h) => h.trim());
  const rows = lines.slice(1).map((l) => splitLine(l).map((c) => c.trim()));
  return { headers: header, rows };
}

function mapColumns(headers: string[]) {
  const dateKeys = new Set(["date", "start date", "timestamp", "time", "datetime", "start time", "downtime date"]);
  const shiftKeys = new Set(["shift", "crew", "team"]);
  const lineKeys = new Set(["line", "asset", "area", "workcenter", "work center", "work centre", "equipment"]);
  const eventKeys = new Set(["event", "reason", "downtime reason", "fault", "stop reason", "stop category", "downtime event"]);
  const durationKeys = new Set([
    "duration",
    "downtime",
    "minutes",
    "downtime minutes",
    "duration min",
    "duration minutes",
    "mins",
    "min",
    "time min",
    "time minutes",
  ]);

  const norm = headers.map(normalizeHeader);

  const pick = (keys: Set<string>) => {
    for (let i = 0; i < norm.length; i++) {
      if (keys.has(norm[i])) return i;
    }
    for (let i = 0; i < norm.length; i++) {
      const h = norm[i];
      for (const k of keys) {
        if (h.includes(k)) return i;
      }
    }
    return -1;
  };

  return {
    dateIdx: pick(dateKeys),
    shiftIdx: pick(shiftKeys),
    lineIdx: pick(lineKeys),
    eventIdx: pick(eventKeys),
    durationIdx: pick(durationKeys),
  };
}

function buildRows(text: string): { data: Row[]; warnings: string[] } {
  const warnings: string[] = [];
  const { headers, rows } = parseDelimited(text);
  if (headers.length === 0) return { data: [], warnings: [] };

  const { dateIdx, shiftIdx, lineIdx, eventIdx, durationIdx } = mapColumns(headers);

  if (dateIdx === -1) warnings.push("Could not detect a Date column.");
  if (lineIdx === -1) warnings.push("Could not detect a Line column.");
  if (eventIdx === -1) warnings.push("Could not detect an Event/Reason column.");
  if (durationIdx === -1) warnings.push("Could not detect a Duration/Minutes column.");

  const data: Row[] = [];

  for (let r = 0; r < rows.length; r++) {
    const row = rows[r];

    const raw: Record<string, string> = {};
    for (let c = 0; c < headers.length; c++) raw[headers[c]] = row[c] ?? "";

    const dt = dateIdx >= 0 ? tryParseDate(row[dateIdx] ?? "") : null;
    const dateISO = dt ? toISODate(dt) : null;

    const line = lineIdx >= 0 ? normalizeLine(row[lineIdx] ?? "") : "UNKNOWN";
    const shift = shiftIdx >= 0 ? normalizeShift(row[shiftIdx] ?? "") : null;
    const event = eventIdx >= 0 ? safeEventName(row[eventIdx] ?? "") : "(Unspecified event)";

    let downtimeMin = 0;
    if (durationIdx >= 0) {
      const n = tryParseNumber(row[durationIdx] ?? "");
      downtimeMin = n != null ? Math.max(0, n) : 0;
    }

    const isTrivial = !dt && line === "UNKNOWN" && event === "(Unspecified event)" && downtimeMin === 0;
    if (isTrivial) continue;

    data.push({
      id: `${r}-${Math.random().toString(16).slice(2)}`,
      dt,
      dateISO,
      shift,
      line,
      event,
      downtimeMin,
      raw,
    });
  }

  if (data.length === 0) warnings.push("No usable rows found. Check that you pasted a header row + data.");
  return { data, warnings };
}

function sum(nums: number[]) {
  let s = 0;
  for (const n of nums) s += n;
  return s;
}

function percentile(val: number, total: number) {
  if (total <= 0) return 0;
  return (val / total) * 100;
}

function mapTabToLine(tab: LineTab): string {
  switch (tab) {
    case "Line A":
      return "LINE A";
    case "Line B":
      return "LINE B";
    case "Line C":
      return "LINE C";
    case "Line D":
      return "LINE D";
  }
}

// ---------- Main Component ----------

export default function OeeExcelPasteDashboard() {
  const [rawText, setRawText] = useState<string>("");
  const [data, setData] = useState<Row[]>([]);
  const [warnings, setWarnings] = useState<string[]>([]);
  const [activeTab, setActiveTab] = useState<LineTab>("Line A");

  const [dateFrom, setDateFrom] = useState<string>("");
  const [dateTo, setDateTo] = useState<string>("");

  const [selectedShifts, setSelectedShifts] = useState<Record<Shift, boolean>>({
    A: true,
    B: true,
    C: true,
    D: true,
  });

  const [selectedEvent, setSelectedEvent] = useState<string | null>(null);
  const [search, setSearch] = useState<string>("");

  const fileInputRef = useRef<HTMLInputElement | null>(null);

  // Load previous state
  useEffect(() => {
    try {
      const saved = localStorage.getItem("oee_paste_text_v1");
      const savedFilters = localStorage.getItem("oee_filters_v1");

      if (saved) {
        setRawText(saved);
        const built = buildRows(saved);
        setData(built.data);
        setWarnings(built.warnings);
      }

      if (savedFilters) {
        const parsed = JSON.parse(savedFilters);
        if (parsed?.activeTab && LINE_TABS.includes(parsed.activeTab)) setActiveTab(parsed.activeTab);
        if (parsed?.dateFrom != null) setDateFrom(parsed.dateFrom);
        if (parsed?.dateTo != null) setDateTo(parsed.dateTo);
        if (parsed?.selectedShifts) setSelectedShifts(parsed.selectedShifts);
      }
    } catch {
      // ignore
    }
  }, []);

  // Persist filters
  useEffect(() => {
    try {
      localStorage.setItem(
        "oee_filters_v1",
        JSON.stringify({ activeTab, dateFrom, dateTo, selectedShifts })
      );
    } catch {
      // ignore
    }
  }, [activeTab, dateFrom, dateTo, selectedShifts]);

  const hasData = data.length > 0;

  // When data is loaded, set default date range if not already set
  useEffect(() => {
    if (!hasData) return;

    const dates = data
      .map((r) => r.dt)
      .filter((d): d is Date => !!d)
      .map((d) => d.getTime());

    if (dates.length === 0) return;

    const minD = new Date(Math.min(...dates));
    const maxD = new Date(Math.max(...dates));
    const minISO = toISODate(minD);
    const maxISO = toISODate(maxD);

    setDateFrom((prev) => (prev ? prev : minISO));
    setDateTo((prev) => (prev ? prev : maxISO));
  }, [hasData, data]);

  const activeLineFilter = useMemo(() => mapTabToLine(activeTab), [activeTab]);

  const enabledShifts = useMemo(() => SHIFT_OPTIONS.filter((s) => selectedShifts[s]), [selectedShifts]);

  const filtered = useMemo(() => {
    const from = dateFrom ? new Date(dateFrom + "T00:00:00") : null;
    const to = dateTo ? new Date(dateTo + "T23:59:59") : null;

    return data
      .filter((r) => {
        if (r.line !== activeLineFilter) return false;

        if (enabledShifts.length < 4) {
          if (r.shift == null) return false;
          if (!enabledShifts.includes(r.shift)) return false;
        }

        if (from || to) {
          if (!r.dt) return false;
          if (from && r.dt < from) return false;
          if (to && r.dt > to) return false;
        }

        if (selectedEvent && r.event !== selectedEvent) return false;

        if (search.trim()) {
          const q = search.trim().toLowerCase();
          const hay = `${r.event} ${r.line} ${r.shift ?? ""} ${r.dateISO ?? ""}`.toLowerCase();
          if (!hay.includes(q)) return false;
        }

        return true;
      })
      .sort((a, b) => {
        const ta = a.dt ? a.dt.getTime() : -Infinity;
        const tb = b.dt ? b.dt.getTime() : -Infinity;
        return tb - ta;
      });
  }, [data, activeLineFilter, enabledShifts, dateFrom, dateTo, selectedEvent, search]);

  const totals = useMemo(() => {
    const totalMin = sum(filtered.map((r) => r.downtimeMin));
    const totalCost = sum(filtered.map((r) => computeRowCostUSD(r)));
    const eventCount = filtered.length;
    const avgMin = eventCount ? totalMin / eventCount : 0;

    return { totalMin, totalCost, eventCount, avgMin };
  }, [filtered]);

  const byEvent = useMemo(() => {
    const map = new Map<string, { event: string; downtimeMin: number; cost: number; count: number }>();
    for (const r of filtered) {
      const cur = map.get(r.event) ?? { event: r.event, downtimeMin: 0, cost: 0, count: 0 };
      cur.downtimeMin += r.downtimeMin;
      cur.cost += computeRowCostUSD(r);
      cur.count += 1;
      map.set(r.event, cur);
    }

    const arr = Array.from(map.values()).sort((a, b) => b.downtimeMin - a.downtimeMin);

    const totalMin = totals.totalMin;
    let cum = 0;
    return arr.map((d) => {
      cum += d.downtimeMin;
      return {
        ...d,
        downtimeHours: d.downtimeMin / 60,
        pct: percentile(d.downtimeMin, totalMin),
        cumPct: percentile(cum, totalMin),
      };
    });
  }, [filtered, totals.totalMin]);

  const byShift = useMemo(() => {
    const map = new Map<string, { shift: string; downtimeMin: number; cost: number }>();
    for (const r of filtered) {
      const key = r.shift ?? "(Unknown)";
      const cur = map.get(key) ?? { shift: key, downtimeMin: 0, cost: 0 };
      cur.downtimeMin += r.downtimeMin;
      cur.cost += computeRowCostUSD(r);
      map.set(key, cur);
    }

    return Array.from(map.values())
      .map((d) => ({ ...d, downtimeHours: d.downtimeMin / 60 }))
      .sort((a, b) => b.downtimeMin - a.downtimeMin);
  }, [filtered]);

  const top10 = byEvent.slice(0, 10);
  const top5 = byEvent.slice(0, 5);

  const paretoData = useMemo(() => {
    return byEvent.slice(0, 15).map((d, idx) => ({
      rank: idx + 1,
      event: d.event,
      downtimeHours: d.downtimeMin / 60,
      cumPct: d.cumPct,
      cost: d.cost,
    }));
  }, [byEvent]);

  const shiftBarData = useMemo(() => {
    return byShift.map((d) => ({
      shift: d.shift,
      downtimeHours: d.downtimeMin / 60,
      cost: d.cost,
    }));
  }, [byShift]);

  const headerLineColor = useMemo(() => {
    return LINE_COLOR[activeLineFilter] ?? LINE_COLOR.UNKNOWN;
  }, [activeLineFilter]);

  const insights = useMemo(() => {
    const out: string[] = [];
    const totalMin = totals.totalMin;

    if (!hasData || totalMin <= 0) {
      out.push("Paste or upload a dataset to generate insights.");
      return out;
    }

    const top = byEvent[0];
    if (top) {
      out.push(
        `#1 event: “${top.event}” accounts for ${round(top.pct, 1)}% of downtime (${fmtHoursFromMin(
          top.downtimeMin
        )}, ${fmtMoney(top.cost)}).`
      );
    }

    const top3 = byEvent.slice(0, 3);
    if (top3.length >= 2) {
      const top3Min = sum(top3.map((d) => d.downtimeMin));
      out.push(
        `Top 3 events drive ${round(percentile(top3Min, totalMin), 1)}% of downtime — good candidates for focused RCA + countermeasures.`
      );
    }

    const worstShift = byShift[0];
    if (worstShift && byShift.length > 1) {
      out.push(
        `Shift with highest downtime: ${worstShift.shift} (${fmtHoursFromMin(
          worstShift.downtimeMin
        )}). Compare staffing, changeovers, and maintenance windows.`
      );
    }

    const idx80 = byEvent.findIndex((d) => d.cumPct >= 80);
    if (idx80 >= 0) {
      out.push(
        `Pareto focus: first ${idx80 + 1} events get you to ~80% of downtime reduction opportunity (within this filter).`
      );
    }

    out.push(`Estimated downtime cost: ${fmtMoney(totals.totalCost)} for the currently filtered window.`);

    return out;
  }, [hasData, totals.totalMin, totals.totalCost, byEvent, byShift]);

  function handleAnalyze() {
    const built = buildRows(rawText);
    setData(built.data);
    setWarnings(built.warnings);

    try {
      localStorage.setItem("oee_paste_text_v1", rawText);
    } catch {
      // ignore
    }

    setSelectedEvent(null);
    setSearch("");
  }

  function handleClearAll() {
    setRawText("");
    setData([]);
    setWarnings([]);
    setSelectedEvent(null);
    setSearch("");
    setDateFrom("");
    setDateTo("");
    setSelectedShifts({ A: true, B: true, C: true, D: true });
    setActiveTab("Line A");

    try {
      localStorage.removeItem("oee_paste_text_v1");
      localStorage.removeItem("oee_filters_v1");
    } catch {
      // ignore
    }
  }

  async function handleFileUpload(file: File) {
    const text = await file.text();
    setRawText(text);

    const built = buildRows(text);
    setData(built.data);
    setWarnings(built.warnings);

    setSelectedEvent(null);
    setSearch("");

    try {
      localStorage.setItem("oee_paste_text_v1", text);
    } catch {
      // ignore
    }
  }

  // Optional dev-only self-tests (run only if you set window.__RUN_OEE_TESTS__ = true)
  useEffect(() => {
    const shouldRun =
      typeof window !== "undefined" && Boolean((window as any).__RUN_OEE_TESTS__);
    if (!shouldRun) return;

    const assert = (cond: any, msg: string) => {
      if (!cond) throw new Error(`OEE self-test failed: ${msg}`);
    };

    // Test 1: TSV parse
    const tsv = "Date\tShift\tLine\tEvent\tDuration (minutes)\n2025-12-01\tA\tLine A\tFilm Break\t10\n";
    const built = buildRows(tsv);
    assert(built.data.length === 1, "TSV should parse 1 row");
    assert(built.data[0].line === "LINE A", "Line normalization should map 'Line A' to 'LINE A'");
    assert(built.data[0].shift === "A", "Shift should parse as A");
    assert(built.data[0].downtimeMin === 10, "Duration minutes should parse as 10");

    // Test 2: CSV quoted commas
    const csv = "Date,Shift,Line,Event,Duration (minutes)\n2025-12-01,A,Line B,\"Sensor, Fault\",5\n";
    const built2 = buildRows(csv);
    assert(built2.data.length === 1, "CSV should parse 1 row");
    assert(built2.data[0].event === "Sensor, Fault", "CSV quoted event should keep comma");

    // Test 3: Cost math
    const cost = computeRowCostUSD({
      id: "x",
      dt: new Date(),
      dateISO: "2025-12-01",
      shift: "A",
      line: "LINE A",
      event: "Test",
      downtimeMin: 60,
      raw: {},
    });
    assert(Math.abs(cost - 1003.5) < 0.001, "60 minutes on LINE A should cost $1003.50");

    // eslint-disable-next-line no-console
    console.log("✅ OEE self-tests passed");
  }, []);

  return (
    <div className="min-h-screen w-full bg-slate-950 text-slate-50">
      <div className="mx-auto max-w-7xl px-4 py-6">
        {/* Header */}
        <div className="flex flex-col gap-3 sm:flex-row sm:items-end sm:justify-between">
          <div className="space-y-2">
            <div className="flex flex-wrap items-center gap-2">
              <div className="h-3 w-3 rounded-full" style={{ background: headerLineColor }} />
              <h1 className="text-2xl font-semibold tracking-tight">OEE Downtime Insights Dashboard</h1>
              <Badge variant="secondary" className="bg-white/10 text-white">
                {activeTab}
              </Badge>
            </div>
            <p className="text-sm text-slate-300">
              Paste your Excel raw data or upload a CSV. Filter by date + shift, then drill into the biggest downtime drivers.
            </p>
          </div>

          <div className="flex flex-wrap items-center gap-2">
            <input
              ref={fileInputRef}
              type="file"
              accept=".csv,.txt"
              className="hidden"
              onChange={(e) => {
                const f = e.target.files?.[0];
                if (f) void handleFileUpload(f);
                e.currentTarget.value = "";
              }}
            />
            <Button
              variant="secondary"
              className="bg-white/10 text-white hover:bg-white/15"
              onClick={() => fileInputRef.current?.click()}
            >
              <FileUp className="mr-2 h-4 w-4" />
              Upload CSV
            </Button>
            <Button
              variant="secondary"
              className="bg-white/10 text-white hover:bg-white/15"
              onClick={handleClearAll}
            >
              <X className="mr-2 h-4 w-4" />
              Reset
            </Button>
          </div>
        </div>

        <div className="mt-6 grid grid-cols-1 gap-4 lg:grid-cols-12">
          {/* Input */}
          <Card className="border-white/10 bg-white/5 lg:col-span-5">
            <CardHeader>
              <CardTitle className="text-base">Paste raw data</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="rounded-2xl border border-white/10 bg-black/30 p-3">
                <p className="text-xs text-slate-300">
                  Expected columns (names can vary): <b>Date</b>, <b>Shift</b>, <b>Line</b>, <b>Event/Reason</b>, <b>Duration (minutes)</b>.
                  Excel copy/paste works best (tab-separated).
                </p>
              </div>

              <Textarea
                value={rawText}
                onChange={(e) => setRawText(e.target.value)}
                placeholder="Paste from Excel here… (include header row)"
                className="min-h-[220px] bg-black/40 text-slate-50 placeholder:text-slate-500"
              />

              <div className="flex flex-wrap items-center justify-between gap-2">
                <div className="text-xs text-slate-400">
                  {hasData ? (
                    <span>
                      Parsed <b>{data.length.toLocaleString()}</b> rows.
                    </span>
                  ) : (
                    <span>Nothing parsed yet.</span>
                  )}
                </div>
                <Button onClick={handleAnalyze} className="rounded-2xl" disabled={rawText.trim().length < 10}>
                  <Sparkles className="mr-2 h-4 w-4" />
                  Analyze
                </Button>
              </div>

              {warnings.length > 0 && (
                <div className="rounded-2xl border border-amber-500/30 bg-amber-500/10 p-3 text-sm">
                  <div className="flex items-start gap-2">
                    <AlertTriangle className="mt-0.5 h-4 w-4 text-amber-300" />
                    <div className="space-y-1">
                      <div className="font-medium text-amber-200">Heads up</div>
                      <ul className="list-disc space-y-1 pl-5 text-amber-100/90">
                        {warnings.map((w, i) => (
                          <li key={i}>{w}</li>
                        ))}
                      </ul>
                    </div>
                  </div>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Filters + KPIs */}
          <Card className="border-white/10 bg-white/5 lg:col-span-7">
            <CardHeader>
              <CardTitle className="flex items-center gap-2 text-base">
                <Filter className="h-4 w-4" /> Filters & KPIs
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 gap-3 sm:grid-cols-2 lg:grid-cols-3">
                <div className="space-y-1 min-w-0">
                  <div className="text-xs text-slate-300">From</div>
                  <Input
                    type="date"
                    value={dateFrom}
                    onChange={(e) => setDateFrom(e.target.value)}
                    className="bg-black/40 w-full min-w-0"
                    disabled={!hasData}
                  />
                </div>
                <div className="space-y-1 min-w-0">
                  <div className="text-xs text-slate-300">To</div>
                  <Input
                    type="date"
                    value={dateTo}
                    onChange={(e) => setDateTo(e.target.value)}
                    className="bg-black/40 w-full min-w-0"
                    disabled={!hasData}
                  />
                </div>
                <div className="space-y-1 min-w-0">
                  <div className="text-xs text-slate-300">Search</div>
                  <Input
                    value={search}
                    onChange={(e) => setSearch(e.target.value)}
                    placeholder="event / shift…"
                    className="bg-black/40 w-full min-w-0"
                    disabled={!hasData}
                  />
                </div>
              </div>

              <div className="rounded-2xl border border-white/10 bg-black/25 p-3">
                <div className="flex flex-wrap items-center justify-between gap-3">
                  <div className="flex items-center gap-2">
                    <span className="text-xs text-slate-300">Shifts:</span>
                    <div className="flex flex-wrap gap-3">
                      {SHIFT_OPTIONS.map((s) => (
                        <label key={s} className="flex cursor-pointer items-center gap-2 text-sm">
                          <Checkbox
                            checked={selectedShifts[s]}
                            onCheckedChange={(v) => setSelectedShifts((prev) => ({ ...prev, [s]: Boolean(v) }))}
                            disabled={!hasData}
                          />
                          <span className="text-slate-200">{s}</span>
                        </label>
                      ))}
                    </div>
                  </div>

                  {selectedEvent ? (
                    <div className="flex flex-wrap items-center gap-2">
                      <Badge className="bg-white/10 text-white">Drill-down: {selectedEvent}</Badge>
                      <Button
                        size="sm"
                        variant="secondary"
                        className="bg-white/10 text-white hover:bg-white/15"
                        onClick={() => setSelectedEvent(null)}
                      >
                        Clear
                      </Button>
                    </div>
                  ) : (
                    <div className="text-xs text-slate-400">Tip: click an event in Top 10 to drill-down.</div>
                  )}
                </div>
              </div>

              <div className="grid grid-cols-2 gap-3 sm:grid-cols-4">
                <Kpi title="Downtime" value={fmtHoursFromMin(totals.totalMin)} sub={`${fmtMin(totals.totalMin)} total`} />
                <Kpi title="Cost Impact" value={fmtMoney(totals.totalCost)} sub="est. downtime cost" />
                <Kpi
                  title="# Events"
                  value={totals.eventCount.toLocaleString()}
                  sub={`avg ${round(totals.avgMin, 1)} min/event`}
                />
                <Kpi
                  title="Top Event Share"
                  value={byEvent[0] ? `${round(byEvent[0].pct, 1)}%` : "—"}
                  sub={byEvent[0] ? safeEventName(byEvent[0].event) : "no data"}
                />
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Tabs + Dashboard */}
        <div className="mt-6">
          <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as LineTab)}>
            <TabsList className="flex w-full flex-nowrap items-center justify-start gap-2 overflow-x-auto bg-white/5 p-2">
              {LINE_TABS.map((t) => (
                <TabsTrigger
                  key={t}
                  value={t}
                  className="shrink-0 whitespace-nowrap rounded-2xl data-[state=active]:bg-white/15"
                >
                  {t}
                </TabsTrigger>
              ))}
            </TabsList>

            {LINE_TABS.map((t) => (
              <TabsContent key={t} value={t} className="mt-4">
                <AnimatePresence mode="wait">
                  <motion.div
                    key={t + (selectedEvent ?? "") + dateFrom + dateTo}
                    initial={{ opacity: 0, y: 8 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -8 }}
                    transition={{ duration: 0.25 }}
                    className="grid grid-cols-1 gap-4 lg:grid-cols-12"
                  >
                    {/* Pareto */}
                    <Card className="border-white/10 bg-white/5 lg:col-span-8">
                      <CardHeader>
                        <CardTitle className="text-base">Pareto: downtime by event (top 15)</CardTitle>
                      </CardHeader>
                      <CardContent className="h-[340px]">
                        {!hasData ? (
                          <EmptyState />
                        ) : paretoData.length === 0 ? (
                          <div className="flex h-full items-center justify-center text-slate-400">No data for current filters.</div>
                        ) : (
                          <ResponsiveContainer width="100%" height="100%">
                            <ComposedChart data={paretoData} margin={{ top: 10, right: 24, left: 0, bottom: 10 }}>
                              <CartesianGrid strokeDasharray="3 3" opacity={0.2} />
                              <XAxis
                                dataKey="rank"
                                tick={{ fill: "#cbd5e1" }}
                                tickLine={{ stroke: "#475569" }}
                                axisLine={{ stroke: "#475569" }}
                                label={{ value: "Rank", position: "insideBottom", offset: -6, fill: "#cbd5e1" }}
                              />
                              <YAxis
                                yAxisId="left"
                                tick={{ fill: "#cbd5e1" }}
                                tickLine={{ stroke: "#475569" }}
                                axisLine={{ stroke: "#475569" }}
                                label={{ value: "Hours", angle: -90, position: "insideLeft", fill: "#cbd5e1" }}
                              />
                              <YAxis
                                yAxisId="right"
                                orientation="right"
                                tick={{ fill: "#cbd5e1" }}
                                tickLine={{ stroke: "#475569" }}
                                axisLine={{ stroke: "#475569" }}
                                domain={[0, 100]}
                                label={{ value: "Cumulative %", angle: 90, position: "insideRight", fill: "#cbd5e1" }}
                              />
                              <Tooltip
                                contentStyle={{
                                  background: "rgba(2,6,23,0.92)",
                                  border: "1px solid rgba(255,255,255,0.12)",
                                  borderRadius: 16,
                                  color: "#e2e8f0",
                                }}
                                formatter={(value: any, name: string) => {
                                  if (name === "downtimeHours") return [`${round(Number(value), 2)} h`, "Downtime"];
                                  if (name === "cumPct") return [`${round(Number(value), 1)}%`, "Cumulative"];
                                  return [value, name];
                                }}
                                labelFormatter={(label: any) => {
                                  const row = paretoData.find((d) => d.rank === label);
                                  return row ? `#${row.rank} • ${row.event}` : `#${label}`;
                                }}
                              />
                              <Legend />
                              <Bar
                                yAxisId="left"
                                dataKey="downtimeHours"
                                name="Downtime"
                                radius={[12, 12, 0, 0]}
                                fill="rgba(255,255,255,0.22)"
                              />
                              <Line
                                yAxisId="right"
                                type="monotone"
                                dataKey="cumPct"
                                name="Cumulative"
                                stroke="rgba(255,255,255,0.75)"
                                strokeWidth={2}
                                dot={false}
                              />
                            </ComposedChart>
                          </ResponsiveContainer>
                        )}
                      </CardContent>
                      <CardContent className="pt-0">
                        <div className="text-xs text-slate-400">
                          Click an event in Top 10 / Top 5 to drill-down and isolate it in the event log.
                        </div>
                      </CardContent>
                    </Card>

                    {/* Insights */}
                    <Card className="border-white/10 bg-white/5 lg:col-span-4">
                      <CardHeader>
                        <CardTitle className="text-base">Key insights</CardTitle>
                      </CardHeader>
                      <CardContent className="space-y-3">
                        {insights.map((s, i) => (
                          <div key={i} className="rounded-2xl border border-white/10 bg-black/25 p-3 text-sm text-slate-200">
                            {s}
                          </div>
                        ))}
                        <div className="rounded-2xl border border-white/10 bg-black/20 p-3 text-xs text-slate-300">
                          Downtime cost rates used: Line A/B = <b>$1,003.50/hr</b>; Line C/D = <b>$1,299.33/hr</b>.
                        </div>
                      </CardContent>
                    </Card>

                    {/* Breakdown */}
                    <Card className="border-white/10 bg-white/5 lg:col-span-6">
                      <CardHeader>
                        <CardTitle className="text-base">Downtime by shift</CardTitle>
                      </CardHeader>
                      <CardContent className="h-[280px]">
                        {!hasData ? (
                          <EmptyState />
                        ) : (
                          <ResponsiveContainer width="100%" height="100%">
                            <BarChart data={shiftBarData} margin={{ top: 10, right: 18, left: 0, bottom: 10 }}>
                              <CartesianGrid strokeDasharray="3 3" opacity={0.2} />
                              <XAxis dataKey="shift" tick={{ fill: "#cbd5e1" }} axisLine={{ stroke: "#475569" }} />
                              <YAxis tick={{ fill: "#cbd5e1" }} axisLine={{ stroke: "#475569" }} />
                              <Tooltip
                                contentStyle={{
                                  background: "rgba(2,6,23,0.92)",
                                  border: "1px solid rgba(255,255,255,0.12)",
                                  borderRadius: 16,
                                  color: "#e2e8f0",
                                }}
                                formatter={(value: any, name: string) => {
                                  if (name === "downtimeHours") return [`${round(Number(value), 2)} h`, "Downtime"];
                                  if (name === "cost") return [fmtMoney(Number(value)), "Cost"];
                                  return [value, name];
                                }}
                              />
                              <Bar
                                dataKey="downtimeHours"
                                name="Downtime"
                                radius={[12, 12, 0, 0]}
                                fill={LINE_COLOR[activeLineFilter] ?? "rgba(255,255,255,0.22)"}
                              />
                            </BarChart>
                          </ResponsiveContainer>
                        )}
                      </CardContent>
                    </Card>

                    {/* Top Events */}
                    <Card className="border-white/10 bg-white/5 lg:col-span-6">
                      <CardHeader>
                        <CardTitle className="text-base">Top events</CardTitle>
                      </CardHeader>
                      <CardContent className="grid grid-cols-1 gap-3 md:grid-cols-2">
                        <TopList title="Top 10" items={top10} totalMin={totals.totalMin} onPick={setSelectedEvent} active={selectedEvent} />
                        <TopList title="Top 5" items={top5} totalMin={totals.totalMin} onPick={setSelectedEvent} active={selectedEvent} />
                      </CardContent>
                    </Card>

                    {/* Event Log */}
                    <Card className="border-white/10 bg-white/5 lg:col-span-12">
                      <CardHeader>
                        <CardTitle className="text-base">Event log</CardTitle>
                      </CardHeader>
                      <CardContent>
                        {!hasData ? (
                          <EmptyState />
                        ) : filtered.length === 0 ? (
                          <div className="flex items-center justify-center py-10 text-slate-400">No rows match the current filters.</div>
                        ) : (
                          <div className="overflow-hidden rounded-2xl border border-white/10">
                            <div className="max-h-[420px] overflow-auto">
                              <Table>
                                <TableHeader className="sticky top-0 bg-slate-950/70 backdrop-blur">
                                  <TableRow>
                                    <TableHead className="text-slate-200">Date</TableHead>
                                    <TableHead className="text-slate-200">Shift</TableHead>
                                    <TableHead className="text-slate-200">Line</TableHead>
                                    <TableHead className="text-slate-200">Event</TableHead>
                                    <TableHead className="text-right text-slate-200">Downtime</TableHead>
                                    <TableHead className="text-right text-slate-200">Cost</TableHead>
                                  </TableRow>
                                </TableHeader>
                                <TableBody>
                                  {filtered.slice(0, 300).map((r) => {
                                    const cost = computeRowCostUSD(r);
                                    const lineColor = LINE_COLOR[r.line] ?? LINE_COLOR.UNKNOWN;
                                    return (
                                      <TableRow key={r.id} className="hover:bg-white/5">
                                        <TableCell className="whitespace-nowrap text-slate-200">{r.dateISO ?? "—"}</TableCell>
                                        <TableCell className="text-slate-200">{r.shift ?? "—"}</TableCell>
                                        <TableCell className="whitespace-nowrap">
                                          <span className="inline-flex items-center gap-2">
                                            <span className="h-2 w-2 rounded-full" style={{ background: lineColor }} />
                                            <span className="text-slate-200">{r.line.replace("LINE ", "Line ")}</span>
                                          </span>
                                        </TableCell>
                                        <TableCell className="text-slate-200">{r.event}</TableCell>
                                        <TableCell className="text-right text-slate-200">{fmtMin(r.downtimeMin)}</TableCell>
                                        <TableCell className="text-right text-slate-200">{fmtMoney(cost)}</TableCell>
                                      </TableRow>
                                    );
                                  })}
                                </TableBody>
                              </Table>
                            </div>
                            <div className="flex flex-wrap items-center justify-between gap-2 bg-black/20 px-3 py-2 text-xs text-slate-400">
                              <span>
                                Showing <b>{Math.min(filtered.length, 300).toLocaleString()}</b> of <b>{filtered.length.toLocaleString()}</b> rows (cap for performance).
                              </span>
                              {selectedEvent && (
                                <Button
                                  size="sm"
                                  variant="secondary"
                                  className="bg-white/10 text-white hover:bg-white/15"
                                  onClick={() => setSelectedEvent(null)}
                                >
                                  Clear drill-down
                                </Button>
                              )}
                            </div>
                          </div>
                        )}
                      </CardContent>
                    </Card>
                  </motion.div>
                </AnimatePresence>
              </TabsContent>
            ))}
          </Tabs>
        </div>

        <Separator className="my-8 bg-white/10" />

        <div className="text-xs text-slate-400">
          <div className="max-w-4xl space-y-2">
            <div className="font-medium text-slate-300">Tips for even better insights</div>
            <ul className="list-disc space-y-1 pl-5">
              <li>
                Add <b>Category</b> (Mechanical / Electrical / Sanitation / Changeover) to allocate resources.
              </li>
              <li>
                Add <b>Start/End timestamps</b> to build a downtime timeline and detect clustering.
              </li>
              <li>
                Add <b>SKU / Recipe</b> to see if downtime spikes on specific products.
              </li>
              <li>
                Add <b>Planned vs Unplanned</b> to keep OEE efforts focused on controllable loss.
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
}

function EmptyState() {
  return (
    <div className="flex h-full items-center justify-center rounded-2xl border border-white/10 bg-black/20 p-6 text-center">
      <div className="max-w-md space-y-2">
        <div className="text-sm font-medium text-slate-200">No data yet</div>
        <div className="text-xs text-slate-400">
          Paste Excel data (with header row) and click <b>Analyze</b>.
        </div>
      </div>
    </div>
  );
}

function Kpi({ title, value, sub }: { title: string; value: string; sub: string }) {
  return (
    <div className="rounded-2xl border border-white/10 bg-black/25 p-3">
      <div className="text-xs text-slate-400">{title}</div>
      <div className="mt-1 text-xl font-semibold tracking-tight text-slate-50">{value}</div>
      <div className="mt-1 line-clamp-2 text-xs text-slate-300">{sub}</div>
    </div>
  );
}

function TopList({
  title,
  items,
  totalMin,
  onPick,
  active,
}: {
  title: string;
  items: Array<{ event: string; downtimeMin: number; cost: number; count: number; pct: number; cumPct: number }>;
  totalMin: number;
  onPick: (event: string) => void;
  active: string | null;
}) {
  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between">
        <div className="text-sm font-medium text-slate-200">{title}</div>
        <Badge variant="secondary" className="bg-white/10 text-white">
          {items.length} events
        </Badge>
      </div>

      <div className="overflow-hidden rounded-2xl border border-white/10 bg-black/20">
        <div className="max-h-[240px] overflow-auto">
          {items.length === 0 ? (
            <div className="px-3 py-8 text-center text-sm text-slate-400">No events.</div>
          ) : (
            <div className="divide-y divide-white/10">
              {items.map((d, idx) => {
                const pct = round(percentile(d.downtimeMin, totalMin), 1);
                const isActive = active === d.event;
                return (
                  <button
                    key={d.event + idx}
                    onClick={() => onPick(d.event)}
                    className={`w-full px-3 py-2 text-left transition hover:bg-white/5 ${isActive ? "bg-white/10" : ""}`}
                  >
                    <div className="flex items-start justify-between gap-3">
                      <div className="min-w-0">
                        <div className="truncate text-sm text-slate-100">#{idx + 1} {d.event}</div>
                        <div className="mt-0.5 flex flex-wrap items-center gap-2 text-xs text-slate-400">
                          <span>{fmtHoursFromMin(d.downtimeMin)}</span>
                          <span>•</span>
                          <span>{fmtMoney(d.cost)}</span>
                          <span>•</span>
                          <span>{pct}%</span>
                          <span>•</span>
                          <span>{d.count} stops</span>
                        </div>
                      </div>
                      <Badge className="bg-white/10 text-white">{pct}%</Badge>
                    </div>
                  </button>
                );
              })}
            </div>
          )}
        </div>
      </div>

      <div className="text-[11px] text-slate-400">Tip: use Top 5 for quick wins, Top 10 for sustained improvement.</div>
    </div>
  );
}
